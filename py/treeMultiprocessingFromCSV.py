#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Aug  4 10:25:24 2022

@author: joe
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Jun 28 23:36:22 2021
@author: Joe
"""

#import needed libraries
import pandas as pd
import numpy as np
#import matplotlib.pyplot as plt
import matplotlib.path as mpltPath
#import matplotlib as mpl
#from mpl_toolkits.mplot3d import Axes3D
from scipy.spatial import Voronoi #, voronoi_plot_2d
import os
import laspy
from multiprocessing import Pool
from pyproj import Transformer
#from datetime import datetime
import json

#convert tree points inside the tile to voronoi polygons
def voronoi_funct(input_dataframe):
    '''
    Parameters
    ----------
    input_dataframe : Pandas Dataframe
        DESCRIPTION. A pandas dataframe containing the contents or a subset of contents of the NYC Street tree Census. 
    Returns
    -------
    regions : a list of lists of points representing the polygon output of voronoi objects, used as the input for clipTreeCloud.
    '''
    df = input_dataframe[['x_sp','y_sp']]
    point_array = df.to_numpy()
    vor = Voronoi(point_array)
    regions = []
    for region in vor.regions:
        region_points = []
        for point_index in region:
            region_points.append((vor.vertices[point_index]).tolist())
        regions.append(region_points)
    return regions

def convertCoords(x,y):
    '''
    Parameters
    ----------
    x : FLOAT
        DESCRIPTION. cartesian x coordinate in state plane coordinate system for NY, long island (EPSG 2263) 
    y : FLOAT
        DESCRIPTION. cartesian y coordinate in state plane coordinate system for NY, long island (EPSG 2263) 
    Returns
    -------
    lat : FLOAT
        DESCRIPTION. latitude in WGS 1984 (EPSG 4326) 
    lon : FLOAT
        DESCRIPTION. longitude in WGS 1984 (EPSG 4326)
    '''
    transformer = Transformer.from_crs("epsg:2263", "epsg:4326")
    lat, lon = transformer.transform(x, y)
    return lat, lon

def clipTreeCloud(polygon,lasFileName):
    '''
    Parameters
    ----------
    polygon : list of vertices
        DESCRIPTION. A single sub-list of vertices generated by voronoi_funct. 
        A single element of the regions list should be provided with a index, loop, or by multiprocessing.
    Returns
    -------
    none 
    Writes a single tree point cloud to a JSON file readable by the Deck.gl component of the Mapbox UI.
    '''
    
    # check that the list of vertices is long enough to form a closed shape
    if len(polygon) >= 3:
        # interpret verticies as a Matplotlib object 
        path = mpltPath.Path(polygon)
        # create working copies of the master lidar point cloud and tree census files
        lidar_df_2 = lidar_df.copy()
        trees_df_2 = trees_df.copy()
        # isolate x,y coordinates of the point cloud to an array to their relationship to the path object can be checked
        lidar_points = lidar_df[['X','Y']]
        lidar_points = lidar_points.to_numpy()
        # check if each set of coordinates from the point cloud fall inside the path and generate a list of boolean conditions
        lidar_df_2['inside'] = path.contains_points(lidar_points)
        lidar_df_2 = lidar_df_2.loc[lidar_df_2.inside, :]
        # check which tree from the census falls inside the path in question so tree's attributes can be accessed
        tree_stem = trees_df_2[['x_sp','y_sp']]
        tree_stem = tree_stem.to_numpy()
        trees_df_2['inside'] = path.contains_points(tree_stem)
        trees_df_2 = trees_df_2.loc[trees_df_2.inside, :].reset_index()
        # retrieve tree ID from the census, will be used to save the point cloud
        tree_id = trees_df_2.iloc[0]['tree_id']
        # calculate a circular buffer for the tree's canopy based on an estimate derived from tree trunk diameter, stored in the census data
        tree_dbh_ft = trees_df_2.iloc[0]['tree_dbh'] / 12
        tree_dbh_m = tree_dbh_ft / 3.28
        trunk_area_sq_m = 3.1415926 * ( ( tree_dbh_m / 2 ) ** 2 )
        canopy_diameter_m = 7 + 28.2 * trunk_area_sq_m
        canopy_radius_m = canopy_diameter_m / 2
        canopy_radius = canopy_radius_m * 1.5 * 3.28 #1.5 is margin of error/buffer
        # distance from trunk filter checks euclidian distance and drops points that fall outside the above radius
        lidar_df_2 = lidar_df_2[ ( ( (lidar_df_2['X'] - trees_df_2.iloc[0]['x_sp'])**2 + (lidar_df_2['Y'] - trees_df_2.iloc[0]['y_sp'])**2 ) ** 0.5 ) < canopy_radius ]
        lidar_df_2 = lidar_df_2.dropna(axis=0, how='any')
        # label the columns of the lidar dataframe, remove the bool field as it is no longer needed
        #lidar_df_2.columns = ['X', 'Y', 'Z', 'intens', 'class', 'return_number', 'number_of_returns', 'bool']
        #lidar_df_2 = lidar_df_2.drop(['bool'],axis=1)
        # normalize lidar return intensity (brightness) 
        #lidar_df_2['intens'] = (lidar_df_2['intens']-lidar_df_2['intens'].min())/(lidar_df_2['intens'].max()-lidar_df_2['intens'].min())
        # find the average ground elevation under the tree and adjust point cloud height so it renders on the "ground" in Mapbox
        ground_df = lidar_df_2[lidar_df_2['class'].astype(int)==2]
        lidar_df_2['Z'] = (lidar_df_2['Z'] - ground_df['Z'].mean())/3.28
        # save a CSV of X,Y,Z, etc. with the base of the tree trunk at the origin (0,0,0), useful for rendering in other applications
        lidar_df_zeroed = lidar_df_2.copy()
        lidar_df_zeroed['X'] = lidar_df_zeroed['X'] - trees_df_2.iloc[0]['x_sp']
        lidar_df_zeroed['Y'] = lidar_df_zeroed['Y'] - trees_df_2.iloc[0]['y_sp']
        lidar_df_zeroed = lidar_df_zeroed.dropna(axis=0, how='any')
        lidar_df_zeroed.to_csv('csv_out/{}.csv'.format(tree_id), float_format='%.4f')
        #convert from stateplane to lat lon
        lidar_df_2['lat'] = convertCoords(lidar_df_2['X'].astype(float),lidar_df_2['Y'].astype(float))[0]
        lidar_df_2['lon'] = convertCoords(lidar_df_2['X'].astype(float),lidar_df_2['Y'].astype(float))[1]
        #save the single tree point cloud in the schema used by the deck.gl component of the Mapbox viewer
        lidar_df_3 = lidar_df_2[['lat', 'lon', 'Z', 'intens', 'return_number', 'number_of_returns']].copy()
        treeArrayForDeck = lidar_df_3.to_numpy()
        treeArrayForDeck =  treeArrayForDeck.tolist()
        with open('shadeShadingShadedTrees/{}_{}.json'.format(tree_id,lasFileName.split(".")[0]), 'w', encoding='utf-8') as f:
            json.dump(treeArrayForDeck, f, ensure_ascii=False)

    else:
        # used in place of a continue statement which is prone to causing errors in the process
        polygon = polygon


###


# read tree csv into dataframe
tree_csv = 'csv/2015StreetTreesCensus_TREES.csv'
trees_df = pd.read_csv(tree_csv)
# read las files
#lidar_df = pd.DataFrame()

# iterate over accessible lidar point cloud files in a folder called "las/" and verify they are of correct type
for lasFileName in os.listdir('shadeShadingShadedDataframes/'):
    if lasFileName.endswith('.csv'):
        #print('starting process')
        # laspy reads the point cloud into a Pandas dataframe
        lidar_df = pd.read_csv('shadeShadingShadedDataframes/{}'.format(lasFileName))
        #print(lidar_df[['X','Y']])
        #print(trees_df[['x_sp','y_sp']])
        # find bounds of las file
        x_min = lidar_df['X'].min()
        x_max = lidar_df['X'].max()
        y_min = lidar_df['Y'].min()
        y_max = lidar_df['Y'].max()
        #print(x_min,x_max,y_min,y_max)
        # select trees in lidar footprint in a new dataframe
        trees_df2 = trees_df.copy()
        trees_df2 = trees_df2[trees_df2['x_sp']>x_min]
        trees_df2 = trees_df2[trees_df2['x_sp']<x_max]
        trees_df2 = trees_df2[trees_df2['y_sp']>y_min]
        trees_df2 = trees_df2[trees_df2['y_sp']<y_max]
        #print(trees_df2)
        #generate voronoi polygons
        if len(trees_df2)>10:
            vor_trees = voronoi_funct(trees_df2)
            #print(vor_trees)
            #start = datetime.now()
            
            for polygon in vor_trees:
                clipTreeCloud(polygon,lasFileName)
            
            # divide selection of individual trees among all available processing cores 
            # if __name__ == '__main__':
            #     with Pool() as p:
            #         p.map(clipTreeCloud, vor_trees)
            
            #end = datetime.now()
            #duration = end - start
            #duration = duration.total_seconds()
            #print('parallel process seconds: ', duration)
        else:
            continue

    else:
        continue
